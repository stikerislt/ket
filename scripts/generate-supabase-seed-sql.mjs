import fs from "node:fs";
import path from "node:path";

const rootDir = process.cwd();
const sourcesPath = path.join(rootDir, "content", "sources", "ket-knygute-2024-2025.json");
const questionsPath = path.join(rootDir, "content", "questions", "initial-15.lt.json");
const outDir = path.join(rootDir, "supabase", "sql");

const sources = JSON.parse(fs.readFileSync(sourcesPath, "utf8"));
const questions = JSON.parse(fs.readFileSync(questionsPath, "utf8"));

function sanitize(value) {
  return String(value)
    .normalize("NFKD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "_")
    .replace(/^_+|_+$/g, "");
}

function sqlText(value) {
  if (value === null || value === undefined) {
    return "NULL";
  }
  return `'${String(value).replace(/'/g, "''")}'`;
}

function sqlBool(value) {
  return value ? "TRUE" : "FALSE";
}

function sqlIntOrNull(value) {
  return value === null || value === undefined ? "NULL" : String(value);
}

function sourceId(code) {
  return `src_${sanitize(code)}`;
}

function clauseId(sourceCode, sectionCode) {
  return `cl_${sanitize(sourceCode)}_${sanitize(sectionCode)}`;
}

function questionId(externalId, slug) {
  return `q_${sanitize(externalId ?? slug)}`;
}

function optionId(questionExternalIdOrSlug, key) {
  return `qo_${sanitize(questionExternalIdOrSlug)}_${sanitize(key)}`;
}

function questionRefId(questionExternalIdOrSlug, index) {
  return `qr_${sanitize(questionExternalIdOrSlug)}_${index + 1}`;
}

function generateSourcesAndExamSql() {
  const lines = [];
  lines.push("-- Generated by scripts/generate-supabase-seed-sql.mjs");
  lines.push("BEGIN;");
  lines.push("");

  const clauseIdsByRef = new Map();

  for (const sourceDocument of sources.sourceDocuments) {
    const srcId = sourceId(sourceDocument.code);

    lines.push(
      `INSERT INTO "public"."SourceDocument" ("id","code","title","filePath","revisionDate","checksum","createdAt","updatedAt")`,
    );
    lines.push(
      `VALUES (${sqlText(srcId)},${sqlText(sourceDocument.code)},${sqlText(sourceDocument.title)},${sqlText(sourceDocument.filePath)},${sourceDocument.revisionDate ? `${sqlText(sourceDocument.revisionDate)}::timestamp` : "NULL"},${sqlText(sourceDocument.checksum)},NOW(),NOW())`,
    );
    lines.push(
      `ON CONFLICT ("code") DO UPDATE SET "title" = EXCLUDED."title", "filePath" = EXCLUDED."filePath", "revisionDate" = EXCLUDED."revisionDate", "checksum" = EXCLUDED."checksum", "updatedAt" = NOW();`,
    );
    lines.push("");

    for (const clause of sourceDocument.clauses) {
      const clId = clauseId(sourceDocument.code, clause.sectionCode);
      const clauseRefKey = `${sourceDocument.code}::${clause.sectionCode}`;
      clauseIdsByRef.set(clauseRefKey, clId);

      lines.push(
        `INSERT INTO "public"."RuleClause" ("id","sourceDocumentId","sectionCode","excerptLt","pageRef","evidenceLevel","createdAt","updatedAt")`,
      );
      lines.push(
        `VALUES (${sqlText(clId)},${sqlText(srcId)},${sqlText(clause.sectionCode)},${sqlText(clause.excerptLt)},${sqlText(clause.pageRef)},${sqlText(clause.evidenceLevel)},NOW(),NOW())`,
      );
      lines.push(
        `ON CONFLICT ("sourceDocumentId","sectionCode") DO UPDATE SET "excerptLt" = EXCLUDED."excerptLt", "pageRef" = EXCLUDED."pageRef", "evidenceLevel" = EXCLUDED."evidenceLevel", "updatedAt" = NOW();`,
      );
      lines.push("");
    }
  }

  lines.push(
    `INSERT INTO "public"."ExamProfile" ("id","code","label","timeLimitSec","questionCount","passThresholdPct","evidenceStatus","note","createdAt","updatedAt")`,
  );
  lines.push(
    `VALUES ('exam_regitra_sim_v1','REGITRA_SIM_V1','Regitra simuliacija',1800,15,NULL,'INSUFFICIENT_RULE_BASIS','Oficialus teorijos vertinimo slenkstis nepateiktas pateiktoje medzagoje.',NOW(),NOW())`,
  );
  lines.push(
    `ON CONFLICT ("code") DO UPDATE SET "label" = EXCLUDED."label", "timeLimitSec" = EXCLUDED."timeLimitSec", "questionCount" = EXCLUDED."questionCount", "passThresholdPct" = EXCLUDED."passThresholdPct", "evidenceStatus" = EXCLUDED."evidenceStatus", "note" = EXCLUDED."note", "updatedAt" = NOW();`,
  );
  lines.push("");
  lines.push("COMMIT;");
  lines.push("");

  return {
    sql: lines.join("\n"),
    clauseIdsByRef,
  };
}

function generateQuestionsSql(clauseIdsByRef) {
  const lines = [];
  lines.push("-- Generated by scripts/generate-supabase-seed-sql.mjs");
  lines.push("BEGIN;");
  lines.push("");

  for (const question of questions.questions) {
    const qId = questionId(question.externalId, question.slug);
    const qStable = question.externalId ?? question.slug;
    const slugLit = sqlText(question.slug);

    lines.push(`-- ${question.externalId ?? question.slug}`);
    lines.push(
      `INSERT INTO "public"."Question" ("id","externalId","slug","type","topic","difficulty","situationLt","promptLt","mediaUrl","status","evidenceStatus","createdAt","updatedAt")`,
    );
    lines.push(
      `VALUES (${sqlText(qId)},${sqlText(question.externalId)},${slugLit},${sqlText(question.type)},${sqlText(question.topic)},${sqlText(question.difficulty)},${sqlText(question.situationLt)},${sqlText(question.promptLt)},${sqlText(question.mediaUrl)},${sqlText(question.status)},${sqlText(question.evidenceStatus)},NOW(),NOW())`,
    );
    lines.push(
      `ON CONFLICT ("slug") DO UPDATE SET "externalId" = EXCLUDED."externalId", "type" = EXCLUDED."type", "topic" = EXCLUDED."topic", "difficulty" = EXCLUDED."difficulty", "situationLt" = EXCLUDED."situationLt", "promptLt" = EXCLUDED."promptLt", "mediaUrl" = EXCLUDED."mediaUrl", "status" = EXCLUDED."status", "evidenceStatus" = EXCLUDED."evidenceStatus", "updatedAt" = NOW();`,
    );
    lines.push("");

    lines.push(
      `DELETE FROM "public"."QuestionOption" WHERE "questionId" = (SELECT "id" FROM "public"."Question" WHERE "slug" = ${slugLit});`,
    );

    if (question.options.length > 0) {
      lines.push(
        `INSERT INTO "public"."QuestionOption" ("id","questionId","key","textLt","isCorrect","orderRank","explanationLt","createdAt","updatedAt")`,
      );
      lines.push("VALUES");
      const optionRows = question.options.map((option) => {
        return `  (${sqlText(optionId(qStable, option.key))},(SELECT "id" FROM "public"."Question" WHERE "slug" = ${slugLit}),${sqlText(option.key)},${sqlText(option.textLt)},${sqlBool(option.isCorrect)},${sqlIntOrNull(option.orderRank)},${sqlText(option.explanationLt)},NOW(),NOW())`;
      });
      lines.push(`${optionRows.join(",\n")};`);
    }
    lines.push("");

    lines.push(
      `DELETE FROM "public"."QuestionReference" WHERE "questionId" = (SELECT "id" FROM "public"."Question" WHERE "slug" = ${slugLit});`,
    );

    if (question.references.length > 0) {
      lines.push(
        `INSERT INTO "public"."QuestionReference" ("id","questionId","ruleClauseId","isPrimary","createdAt")`,
      );
      lines.push("VALUES");
      const refRows = question.references.map((reference, index) => {
        const refKey = `${reference.sourceCode}::${reference.sectionCode}`;
        const mappedClauseId = clauseIdsByRef.get(refKey);
        if (!mappedClauseId) {
          throw new Error(`Missing clause mapping for reference: ${refKey}`);
        }
        return `  (${sqlText(questionRefId(qStable, index))},(SELECT "id" FROM "public"."Question" WHERE "slug" = ${slugLit}),${sqlText(mappedClauseId)},${sqlBool(reference.isPrimary)},NOW())`;
      });
      lines.push(`${refRows.join(",\n")};`);
    }
    lines.push("");
  }

  lines.push("COMMIT;");
  lines.push("");

  return lines.join("\n");
}

function main() {
  fs.mkdirSync(outDir, { recursive: true });

  const { sql: sourceSql, clauseIdsByRef } = generateSourcesAndExamSql();
  fs.writeFileSync(path.join(outDir, "002_seed_sources_and_exam.sql"), sourceSql, "utf8");

  const questionSql = generateQuestionsSql(clauseIdsByRef);
  fs.writeFileSync(path.join(outDir, "003_seed_questions.sql"), questionSql, "utf8");
}

main();
